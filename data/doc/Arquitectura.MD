# ðŸ—ï¸ Arquitectura de Proyectos con Docker

## ðŸ“‹ DescripciÃ³n General

Este documento describe una arquitectura estÃ¡ndar para proyectos que utilizan Docker Compose. La arquitectura estÃ¡ diseÃ±ada para ser escalable, mantenible y fÃ¡cil de replicar en diferentes tipos de proyectos, no solo ELK.

## ðŸŽ¯ Principios de DiseÃ±o

### 1. **SeparaciÃ³n de Responsabilidades**
- **Build**: Contiene Dockerfiles para construcciÃ³n de imÃ¡genes personalizadas
- **Data**: Almacena configuraciones y datos de aplicaciÃ³n
- **BD**: Persistencia de datos de bases de datos y servicios
- **OrquestaciÃ³n**: Docker Compose para coordinaciÃ³n de servicios

### 2. **Modularidad**
- Cada servicio tiene su propia configuraciÃ³n independiente
- Componentes reutilizables y intercambiables
- Configuraciones separadas por entorno (dev, staging, prod)

### 3. **Escalabilidad**
- Servicios independientes que pueden escalar individualmente
- Redes Docker aisladas para mejor rendimiento
- ConfiguraciÃ³n de recursos por servicio

## ðŸ›ï¸ Estructura de Directorios EstÃ¡ndar

### Estructura General (PatrÃ³n de Referencia)
```
proyecto/
â”œâ”€â”€ ðŸ“ bd/                          # Solo datos de bases de datos
â”‚   â”œâ”€â”€ ðŸ“ postgres-data/           # Datos de PostgreSQL
â”‚   â”œâ”€â”€ ðŸ“ redis-data/              # Datos de Redis
â”‚   â””â”€â”€ ðŸ“ mongodb-data/            # Datos de MongoDB
â”‚
â”œâ”€â”€ ðŸ”¨ build/                        # Solo Dockerfiles
â”‚   â”œâ”€â”€ ðŸ“ {service1}/              # Dockerfile para servicio 1
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ Dockerfile           # Solo estructura base
â”‚   â”‚   â””â”€â”€ ðŸ“„ init-script.sh       # Scripts de inicializaciÃ³n
â”‚   â”œâ”€â”€ ðŸ“ {service2}/              # Dockerfile para servicio 2
â”‚   â””â”€â”€ ðŸ“ {service3}/              # Dockerfile para servicio 3
â”‚
â”œâ”€â”€ ðŸ“Š data/                         # CÃ³digo y configuraciones
â”‚   â”œâ”€â”€ ðŸ“ {service1}/              # CÃ³digo del servicio 1
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ main.py              # CÃ³digo principal
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ requirements.txt     # Dependencias
â”‚   â”‚   â””â”€â”€ ðŸ“ config/              # Configuraciones
â”‚   â”œâ”€â”€ ðŸ“ {service2}/              # CÃ³digo del servicio 2
â”‚   â”œâ”€â”€ ðŸ“ {service3}/              # CÃ³digo del servicio 3
â”‚   â”œâ”€â”€ ðŸ“ scripts/                 # Scripts de utilidad
â”‚   â””â”€â”€ ðŸ“ doc/                     # DocumentaciÃ³n
â”‚
â”œâ”€â”€ ðŸ³ docker-compose.yml           # OrquestaciÃ³n de servicios
â”œâ”€â”€ ðŸ³ docker-compose.override.yml  # Configuraciones de desarrollo
â”œâ”€â”€ ðŸ³ docker-compose.prod.yml      # Configuraciones de producciÃ³n
â”œâ”€â”€ âš™ï¸ .env.example                 # Variables de entorno de ejemplo
â”œâ”€â”€ âš™ï¸ .env                         # Variables de entorno (no versionado)
```

### Estructura EspecÃ­fica de CommentBot
```
commentbot/
â”œâ”€â”€ ðŸ“ bd/                          # Solo datos de bases de datos (vacÃ­o)
â”‚
â”œâ”€â”€ ðŸ”¨ build/                        # Solo Dockerfiles
â”‚   â”œâ”€â”€ ðŸ“ commentbot-core/
â”‚   â”‚   â””â”€â”€ ðŸ“„ Dockerfile           # Solo estructura base (sin CMD)
â”‚   â”œâ”€â”€ ðŸ“ ollama/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ Dockerfile
â”‚   â”‚   â””â”€â”€ ðŸ“„ init-ollama.sh       # Script de inicializaciÃ³n
â”‚   â””â”€â”€ ðŸ“ whisper-service/
â”‚       â”œâ”€â”€ ðŸ“„ Dockerfile
â”‚       â””â”€â”€ ðŸ“„ main.py              # Servicio Whisper
â”‚
â”œâ”€â”€ ðŸ“Š data/                         # CÃ³digo y datos persistentes
â”‚   â”œâ”€â”€ ðŸ“ commentbot-core/          # Servicio FastAPI principal
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ main.py              # Servicio FastAPI
â”‚   â”‚   â””â”€â”€ ðŸ“„ requirements.txt     # Dependencias Python
â”‚   â”œâ”€â”€ ðŸ“ audio-cache/             # Cache de archivos de audio
â”‚   â”œâ”€â”€ ðŸ“ transcripts/             # Transcripciones y resultados
â”‚   â”œâ”€â”€ ðŸ“ models/ollama/           # Modelos de IA descargados
â”‚   â”œâ”€â”€ ðŸ“ scripts/                 # Scripts de utilidad
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ setup.sh
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test.sh
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cleanup.sh
â”‚   â”‚   â””â”€â”€ ðŸ“„ diagnostic.sh
â”‚   â””â”€â”€ ðŸ“ doc/                     # DocumentaciÃ³n tÃ©cnica
â”‚       â”œâ”€â”€ ðŸ“„ Arquitectura.MD
â”‚       â”œâ”€â”€ ðŸ“„ Implementacion.MD
â”‚       â”œâ”€â”€ ðŸ“„ ProyectoComment.MD
â”‚       â”œâ”€â”€ ðŸ“„ CasosDeUso.MD
â”‚       â”œâ”€â”€ ðŸ“„ ResumenEjecutivo.MD
â”‚       â””â”€â”€ ðŸ“„ README.md
â”‚
â”œâ”€â”€ ðŸ“„ main.py                      # Script CLI principal
â”œâ”€â”€ ðŸ“„ test_simple.py               # Script de pruebas
â”œâ”€â”€ ðŸ³ docker-compose.yml           # OrquestaciÃ³n (ejecuta desde docker-compose)
â”œâ”€â”€ âš™ï¸ env.example                  # Variables de entorno
â””â”€â”€ ðŸ“„ README.md                    # DocumentaciÃ³n principal
```

## ðŸ”„ Flujo de Datos GenÃ©rico

```
ðŸ“± Entrada â†’ ðŸ”„ Procesamiento â†’ ðŸ—„ï¸ Almacenamiento â†’ ðŸ“Š VisualizaciÃ³n
     â†“              â†“                â†“                â†“
ðŸ“ Inputs    ðŸ”„ Services      ðŸ“ Databases      ðŸ“Š Dashboards
     â†“              â†“                â†“                â†“
ðŸ“ Logs      ðŸ”„ Pipelines     ðŸ“ Indices        ðŸ“ Reports
```

## ðŸ³ Arquitectura Docker

### **Redes**
```yaml
networks:
  app-network:
    driver: bridge
    # Permite comunicaciÃ³n entre servicios
    # Aislamiento del resto del sistema
    # ConfiguraciÃ³n de IPs estÃ¡ticas si es necesario
```

### **VolÃºmenes**
```yaml
volumes:
  # Configuraciones (read-only)
  - ./data/{service}/config:/etc/{service}/config:ro
  
  # Datos persistentes
  - ./bd/{service}-data:/var/lib/{service}
  
  # Logs y datos temporales
  - ./data/logs:/var/log/{service}
  
  # Archivos compartidos entre servicios
  - ./data/shared:/shared
```

### **Health Checks**
```yaml
healthcheck:
  test: ["CMD-SHELL", "curl -f http://localhost:port/health || exit 1"]
  interval: 30s
  timeout: 10s
  retries: 5
  start_period: 60s
```

## ðŸŽ­ PatrÃ³n de Servicios

### **Estructura de un Servicio**
```
{service}/
â”œâ”€â”€ ðŸ“„ Dockerfile                    # ConstrucciÃ³n de imagen
â”œâ”€â”€ ðŸ“„ .dockerignore                 # Archivos a excluir
â”œâ”€â”€ ðŸ“„ requirements.txt              # Dependencias (si aplica)
â”œâ”€â”€ ðŸ“ config/                       # Configuraciones
â”œâ”€â”€ ðŸ“ scripts/                      # Scripts de inicializaciÃ³n
â””â”€â”€ ðŸ“ tests/                        # Tests del servicio
```

### **Dockerfile EstÃ¡ndar**
```dockerfile
# Imagen base
FROM {base-image}:{version}

# Metadatos
LABEL maintainer="team@company.com"
LABEL version="1.0"
LABEL description="Service description"

# Variables de entorno
ENV SERVICE_NAME={service}
ENV SERVICE_VERSION=1.0

# Directorio de trabajo
WORKDIR /app

# Instalar dependencias
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copiar cÃ³digo
COPY . .

# Exponer puerto
EXPOSE {port}

# Comando de inicio
CMD ["python", "main.py"]
```

### **Servicio en Docker Compose**
```yaml
{service}:
  build:
    context: ./build/{service}
    dockerfile: Dockerfile
    args:
      - BUILD_ENV=production
  image: {service}:latest
  container_name: {service}
  environment:
    - SERVICE_NAME={service}
    - ENVIRONMENT=production
  volumes:
    - ./data/{service}/config:/etc/{service}/config:ro
    - ./bd/{service}-data:/var/lib/{service}
    - ./data/logs:/var/log/{service}
  ports:
    - "{host-port}:{container-port}"
  networks:
    - app-network
  depends_on:
    {dependency-service}:
      condition: service_healthy
  healthcheck:
    test: ["CMD-SHELL", "curl -f http://localhost:{port}/health"]
    interval: 30s
    timeout: 10s
    retries: 5
  restart: unless-stopped
  deploy:
    resources:
      limits:
        memory: 1G
        cpus: '0.5'
      reservations:
        memory: 512M
        cpus: '0.25'
```

## ðŸ”§ PatrÃ³n de ConfiguraciÃ³n

### **Estructura de ConfiguraciÃ³n**
```
data/
â”œâ”€â”€ ðŸ“ {service}/
â”‚   â”œâ”€â”€ ðŸ“„ {service}.yml              # ConfiguraciÃ³n principal
â”‚   â”œâ”€â”€ ðŸ“ config/                    # Configuraciones adicionales
â”‚   â”œâ”€â”€ ðŸ“ templates/                 # Plantillas de configuraciÃ³n
â”‚   â””â”€â”€ ðŸ“ {custom}/                  # Archivos personalizados
```

### **Mapeo de VolÃºmenes**
```yaml
volumes:
  # ConfiguraciÃ³n principal
  - ./data/{service}/config/{service}.yml:/etc/{service}/{service}.yml:ro
  
  # Configuraciones adicionales
  - ./data/{service}/config:/etc/{service}/conf.d:ro
  
  # Plantillas
  - ./data/{service}/templates:/etc/{service}/templates:ro
```

## ðŸ“Š PatrÃ³n de Monitoreo

### **Script de Monitoreo**
```bash
#!/bin/bash
# monitor_{service}.sh

# ConfiguraciÃ³n
SERVICE_NAME="{service}"
HEALTH_URL="http://localhost:{port}/health"
METRICS_URL="http://localhost:{port}/metrics"
LOG_FILE="/var/log/monitor.log"

# FunciÃ³n de logging
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >> "$LOG_FILE"
}

# Verificar salud del servicio
if curl -f "$HEALTH_URL" > /dev/null 2>&1; then
    log "$SERVICE_NAME is healthy"
    
    # Verificar mÃ©tricas
    if curl -s "$METRICS_URL" > /dev/null 2>&1; then
        log "$SERVICE_NAME metrics endpoint is accessible"
    else
        log "WARNING: $SERVICE_NAME metrics endpoint is not accessible"
    fi
else
    log "ERROR: $SERVICE_NAME is not healthy"
    exit 1
fi
```

### **Servicio de Monitoreo**
```yaml
{service}-monitor:
  image: curlimages/curl:latest
  volumes:
    - ./data/monitoring/monitor_{service}.sh:/monitor.sh:ro
    - ./data/logs:/var/log
  command: ["sh", "/monitor.sh"]
  restart: unless-stopped
  networks:
    - app-network
  depends_on:
    - {service}
```

## ðŸš€ PatrÃ³n de Escalado

### **Escalado Horizontal**
```yaml
# Escalar servicios individuales
docker compose up -d --scale {service}=3

# Escalar con balanceo de carga
{service}:
  deploy:
    replicas: 3
    resources:
      limits:
        memory: 1G
        cpus: '0.5'
    restart_policy:
      condition: on-failure
      delay: 5s
      max_attempts: 3
```

### **Escalado Vertical**
```yaml
deploy:
  resources:
    limits:
      memory: 2G
      cpus: '1.0'
    reservations:
      memory: 1G
      cpus: '0.5'
```

## ðŸ” PatrÃ³n de Seguridad

### **Variables de Entorno**
```bash
# .env
# ConfiguraciÃ³n general
ENVIRONMENT=production
APP_VERSION=1.0.0

# Credenciales de servicios
{service1}_USER=user1
{service1}_PASSWORD=secure_password1
{service2}_USER=user2
{service2}_PASSWORD=secure_password2

# ConfiguraciÃ³n de red
NETWORK_NAME=app-network
NETWORK_DRIVER=bridge

# Recursos
{service1}_MEMORY_LIMIT=1G
{service1}_CPU_LIMIT=0.5
```

### **ConfiguraciÃ³n de Seguridad**
```yaml
environment:
  # Habilitar seguridad
  - SECURITY_ENABLED=true
  - SSL_ENABLED=true
  
  # ConfiguraciÃ³n de autenticaciÃ³n
  - AUTH_TYPE=jwt
  - JWT_SECRET=${JWT_SECRET}
  
  # ConfiguraciÃ³n de red
  - BIND_ADDRESS=0.0.0.0
  - ALLOWED_ORIGINS=${ALLOWED_ORIGINS}
```

## ðŸ“ˆ PatrÃ³n de Logging

### **Estructura de Logs**
```json
{
  "@timestamp": "2025-01-01T12:00:00Z",
  "level": "INFO",
  "service": "service-name",
  "version": "1.0.0",
  "environment": "production",
  "message": "Log message",
  "metadata": {
    "user_id": "12345",
    "request_id": "req-67890",
    "duration_ms": 150,
    "ip_address": "192.168.1.100"
  },
  "context": {
    "function": "process_request",
    "line": 45,
    "file": "main.py"
  }
}
```

### **ConfiguraciÃ³n de Logging**
```yaml
# En docker-compose.yml
logging:
  driver: "json-file"
  options:
    max-size: "10m"
    max-file: "3"
    labels: "service={service}"
    env: "ENVIRONMENT"
```

## ðŸŽ¯ Casos de Uso de la Arquitectura

### **1. AplicaciÃ³n Web con Microservicios**
- Servicios independientes para cada funcionalidad
- Base de datos compartida o separada
- API Gateway para enrutamiento
- Load balancer para escalabilidad

### **2. Sistema de AnÃ¡lisis de Datos**
- Servicios de ingesta de datos
- Procesamiento en batch y tiempo real
- Almacenamiento distribuido
- Dashboards de visualizaciÃ³n

### **3. Sistema de Monitoreo y Observabilidad**
- Agentes de recolecciÃ³n de mÃ©tricas
- Servicios de procesamiento y alertas
- Base de datos de series temporales
- Interfaces de visualizaciÃ³n

### **4. Plataforma de Machine Learning**
- Servicios de entrenamiento de modelos
- Servicios de inferencia
- Almacenamiento de datos y modelos
- Monitoreo de rendimiento

## ðŸ”„ Pasos para Replicar la Arquitectura

### **1. Crear Estructura Base**
```bash
# Crear directorios principales
mkdir -p {bd,build,data}

# Crear estructura para cada servicio
for service in service1 service2 service3; do
    mkdir -p bd/${service}-data
    mkdir -p build/${service}
    mkdir -p data/${service}/{config,templates,scripts}
done

# Crear directorios adicionales
mkdir -p data/{monitoring,scripts,shared}
```

### **2. Copiar Patrones de Dockerfile**
```bash
# Para cada servicio
for service in service1 service2 service3; do
    cp -r build/{service}/ Dockerfile
    # Adaptar para el nuevo servicio
    sed -i "s/{service}/$service/g" Dockerfile
done
```

### **3. Configurar Docker Compose**
```yaml
# Crear docker-compose.yml base
version: '3.8'

services:
  # Agregar servicios uno por uno
  {service1}:
    build:
      context: ./build/{service1}
      dockerfile: Dockerfile
    # Configurar volÃºmenes, redes y dependencias

networks:
  app-network:
    driver: bridge
```

### **4. Implementar Health Checks**
```yaml
healthcheck:
  test: ["CMD-SHELL", "curl -f http://localhost:{port}/health"]
  interval: 30s
  timeout: 10s
  retries: 5
  start_period: 60s
```

### **5. Configurar Monitoreo**
```bash
# Crear script de monitoreo para cada servicio
for service in service1 service2 service3; do
    cat > data/monitoring/monitor_${service}.sh << 'EOF'
#!/bin/bash
# monitor_${service}.sh
# Implementar verificaciones de salud
EOF
    chmod +x data/monitoring/monitor_${service}.sh
done
```

## ðŸ“š Mejores PrÃ¡cticas

### **1. Nomenclatura**
- Usar nombres descriptivos y consistentes
- Seguir convenciones de Docker (lowercase, hyphens)
- Mantener versiones en tags semÃ¡nticos
- Usar prefijos para identificar entornos

### **2. ConfiguraciÃ³n**
- Separar configuraciones por entorno
- Usar variables de entorno para secretos
- Documentar todas las opciones de configuraciÃ³n
- Implementar validaciÃ³n de configuraciÃ³n

### **3. Monitoreo**
- Implementar health checks para todos los servicios
- Crear mÃ©tricas de rendimiento
- Configurar alertas automÃ¡ticas
- Implementar logging estructurado

### **4. Seguridad**
- Usar redes aisladas
- Implementar autenticaciÃ³n y autorizaciÃ³n
- Rotar credenciales regularmente
- Escanear imÃ¡genes en busca de vulnerabilidades

### **5. Mantenimiento**
- Usar tags especÃ­ficos de versiÃ³n
- Implementar backups automÃ¡ticos
- Documentar procedimientos de actualizaciÃ³n
- Implementar rollback automÃ¡tico

## ðŸ” Consideraciones de Rendimiento

### **Recursos del Sistema**
- **MÃ­nimo**: 4GB RAM, 2 CPU cores
- **Recomendado**: 8GB RAM, 4 CPU cores
- **ProducciÃ³n**: 16GB+ RAM, 8+ CPU cores

### **Optimizaciones**
- Usar imÃ¡genes base optimizadas
- Implementar multi-stage builds
- Configurar lÃ­mites de recursos apropiados
- Implementar cachÃ© de capas Docker

### **Monitoreo de Recursos**
```bash
# Ver uso de recursos
docker stats

# Ver logs de rendimiento
docker compose logs -f {service}

# Analizar uso de recursos
docker system df
docker image ls --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

## ðŸ› ï¸ Herramientas de Desarrollo

### **Scripts de Utilidad**
```bash
# scripts/dev-setup.sh
#!/bin/bash
# ConfiguraciÃ³n del entorno de desarrollo

# Crear archivo .env si no existe
if [ ! -f .env ]; then
    cp .env.example .env
    echo "Archivo .env creado desde .env.example"
fi

# Construir imÃ¡genes
docker compose build

# Levantar servicios
docker compose up -d

echo "Entorno de desarrollo configurado"
```

### **Scripts de ProducciÃ³n**
```bash
# scripts/prod-deploy.sh
#!/bin/bash
# Despliegue en producciÃ³n

# Verificar variables de entorno
if [ -z "$ENVIRONMENT" ]; then
    echo "ERROR: ENVIRONMENT no estÃ¡ definida"
    exit 1
fi

# Desplegar con configuraciÃ³n de producciÃ³n
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

echo "Despliegue en producciÃ³n completado"
```

---

**Esta arquitectura estÃ¡ diseÃ±ada para ser flexible, escalable y fÃ¡cil de replicar. Adapta los patrones segÃºn las necesidades especÃ­ficas de tu proyecto y el tipo de aplicaciÃ³n que estÃ©s desarrollando.**
